# N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다.
# 이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서가 다른 것은 같은 경우로 구분한다.

# 입력 조건 
# 1. 첫째 줄에 N, M이 주어진다. (1<=N<=100, 1<=M<=10000)
# 2. 이후의 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10000보다 작거나 같은 자연수이다.

# 출력 조건 
# 첫째 줄에 경우의 수 X를 출력한다.
# 불가능할 때는 -1을 출력한다.
import sys
n, m = map(int, input().split())
arr_val = []
for _ in range(n) : 
     arr_val.append(int(sys.stdin.readline()))

d = [10001] * (m+1)
d[0] = 0
for i in range(n) : 
     for j in range(arr_val[i], m+1) :
          if d[j-arr_val[i]] != 100001 : # (i-k)원을 만드는 방법이 존재하는 경우
               d[j] = min(d[j], d[j-arr_val[i]]+1)

if d[m] == 10001 : # 최종적으로 M원을 만드는 방법이 없는 경우
     print(-1)
else :
     print(d[m])
     
# 문제 해설
# 금액 i를 만들 수 있는 최소한의 화폐 개수를 Ai, 화폐의 단위를 k라고 했을 때,
# 다음과 같으 점화식을 작성할 수 있다. Ai-k는 금액 (i-k)를 만들 수 있는 최소한의 화폐 개수를 의미한다.
# * Ai-k를 만드는 방법이 존재하는 경우, Ai = min(Ai, Ai-k+1)
# * Ai-k를 만드는 방법이 존재하지 않는 경우, Ai= 10001